---
layout: post
title: 三次握手、四次挥手
categories: 计算机网络
description: 三次握手、四次挥手。
keywords: 计算机网络，tcp/ip 
---



### 3次握手
- 客户端发送一个SYN包，SYN位为1，以及seq=x（SYN_SEND状态）
- 服务端发送一个SYN+ACK包，SYN位为1，ACK位为1，seq =y，ack=x+1（SYN_RECV状态）；
- 客户端确认ack无误后，发送一个ACK包，ACK位为1，ack=y + 1（ESTABLISHED状态）；


### 4次挥手（假设客户端主动关闭）

- 客户端发送一个FIN包，seq=m（客户端进入FIN-WAIT_1）
- 服务端发送一个ACK包，ack=m+1（服务端进入CLOSE_WAIT，客户端进入FIN_WAIT_2）
- 服务端确认没有数据发送，发送FIN包，seq=n（服务器进入LAST_ACK）
- 客户端发送ACK包，ack=n+1（客户端进入TIME_WAIT，2MSL后关闭）

### 流程

![状态图](/images/posts/net/clipboard.png)


### 常见问题
- 为什么是4次挥手（其实就是问服务端的TIME_WAIT状态）

> 3次握手的时候，ACK和SYN包是一起发送的；但是关闭连接时，服务端收到FIN报文后，可能不立刻关闭，还需要发送未发完的数据，所以先回复一个ACK包，当数据发完确认要断开连接时，才发送FIN包，所以这一点是在2个包发送的而不是一个包发送

- 为什么是2MSL-2倍最大报文生存时间（其实就是问客户端的CLOSE_WAIT）

> 有可能最后一个ACK包丢失了，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文

- 握手一定是3次吗？

> 否，当同时打开的时候，多发了一个包，是4次

- 为什么会有重复ACK？

> 接收方总是返回已经成功接收数据的最大序号+1的ACK，如果中间丢失了报文段，需要就断开了，于是会产生重复ACK

- 为什么是4次挥手（其实就是问服务端的TIME_WAIT状态）？

> 3次握手的时候，ACK和SYN包是一起发送的；但是关闭连接时，服务端收到FIN报文后，可能不立刻关闭，还需要发送未发完的数据，所以先回复一个ACK包，当数据发完确认要断开连接时，才发送FIN包，所以这一点是在2个包发送的而不是一个包发送

- 快速恢复算法中，为什么是执行拥塞避免算法而不是慢启动算法？

> 因为收到重复ACK说明了中间丢失了一个报文段，且后续还有数据流动（否则不会是重复发送ACK），为了避免流量突然变小

- 报文段丢失后，什么时候可以发送新的报文段？

> 未被确认的报文段大于cwnd的时候，才可以发送新的报文段